"""
CVE-lookup.py
"""
import argparse
import csv
import json
import os
import time
import colorama
import requests
from fake_useragent import UserAgent

# init the colorama module
colorama.init()

GREEN = colorama.Fore.GREEN
YELLOW = colorama.Fore.YELLOW
GRAY = colorama.Fore.CYAN
RESET = colorama.Fore.RESET
RED = colorama.Fore.RED

DEBUG_MODE = False
CHECK_URL = 'https://ipapi.co/json/'
JSON_DIRECTORY = 'jsons'
FILE_OUT_JSON = 'result_cves.json'
FILE_OUT_CSV = 'result_cves.csv'

ua = UserAgent()


def get_arg():
    """
    Getting command line arguments
    :return: Dict of args
    """
    parser = argparse.ArgumentParser(description='A tool for quickly retrieving the descriptions and CVSS scores for '
                                                 'a large number of CVEs and listing them in order of severity.')
    parser.add_argument('data', type=str, help='CVE to search', nargs='?')
    parser.add_argument('-f', '--file', help='Path to file containing List CVEs for lookup into a text file')
    parser.add_argument('--debug', help='Debug mode on', action="store_true")
    parser.add_argument('--stats', help='Stats', action="store_true")
    args = vars(parser.parse_args())
    return args


def yes_or_no(question):
    """
    Creates a question
    :return: True if yes, otherwise false
    """
    while True:
        reply = input(question + ' [y/n]? ').lower().strip()
        if reply == 'y':
            return True
        elif reply == 'n':
            return False
        else:
            print("Please select [y/n] only!")


def check_region():
    """
    Checks region
    :return:
    """
    status = False
    print(f"{GREEN}[*] [check_region] Checking region...{RESET}")
    try:
        url = CHECK_URL
        header = {'User-Agent': str(ua.random)}
        response = requests.get(url, headers=header)
        response_json = response.json()
        if response_json['country'] != 'BY':
            print(f"{GREEN}[*] [check_region] Region lookup done!{RESET}")
            print(f"{GREEN}[*] [check_region] Details: {response_json}{RESET}")
            status = True
        else:
            print(f"{RED}[-] [check_region] You are not protected! Details: {response_json}{RESET}!")
    except Exception as e:
        print(f"{RED}[-] [check_region] Something went wrong, error: {e}{RESET}!")
    return status


def file_statistics():
    """
    Statistics of the results file
    :return: None
    """
    items = {}
    with open(f'{FILE_OUT_JSON}', 'r+', encoding='utf-8', newline='') as file:
        items = json.load(file)
    all_count = len(items)
    error_count = 0

    for item in items:
        if 'status' in item:
            error_count += 1

    ok_count = all_count - error_count

    print(f'[*] [file_statistics] File statistics: {RESET}')
    print(f'[*] [file_statistics] All CVEs: {all_count} {RESET}')
    print(f'{GREEN}[*] [file_statistics] OK: {ok_count} ({round(ok_count / all_count * 100, 2)}%){RESET}')
    print(f'{RED}[*] [file_statistics] Error: {error_count} ({round(error_count / all_count * 100, 2)}%){RESET}')


class CVEparser:
    def __init__(self):
        self.base_url = 'https://services.nvd.nist.gov/'
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/111.0'}
        self.work_directory = 'cve'
        self.session = requests.Session()
        # create work folders
        if not os.path.isdir(f'{JSON_DIRECTORY}'):
            os.makedirs(f'{JSON_DIRECTORY}')
        if not os.path.isdir(f'{JSON_DIRECTORY}/{self.work_directory}'):
            os.makedirs(f'{JSON_DIRECTORY}/{self.work_directory}')

    def api_request(self, input):
        """
        Request to NVD API
        :param input: query
        :return: JSON response
        """
        print(f'{GRAY}[*] [api_request] Fetching info using /rest/json/cve/1.0 (input = {input}){RESET}')
        ans = {}
        try:
            # payload = {'name': input}
            response = self.session.get(self.base_url + 'rest/json/cve/1.0/' + input, headers=self.headers)
            ans = response.json()
            print(f'{GREEN}[+] [api_request] API request successful!{RESET}')
            with open(f'{JSON_DIRECTORY}/{self.work_directory}/{input}.json', 'w+', encoding='utf-8',
                      newline='') as file_out:
                json.dump(ans, file_out, ensure_ascii=False)
        except Exception as e:
            print(f'{RED}[-] [api_request] Something went wrong, error: {e}{RESET}!')
        return ans

    def parse_cve(self, cve, response):
        """
        Parses API response and returns result dict
        :param cve: CVE code
        :param response: API response
        :return: result dict
        """
        result = {}
        try:
            result = {
                'cve': cve,
                'description': response["result"]["CVE_Items"][0]["cve"]["description"]["description_data"][0]["value"],
                'cvss': response["result"]["CVE_Items"][0]["impact"]["baseMetricV3"]["cvssV3"]["baseScore"]
            }
            print(f'{GREEN}[+] [parse_cve] Response parse OK!{RESET}')
        except Exception as e:
            print(f'{RED}[!] [parse_cve] Parse error: {str(e)}{RESET}')
        return result

    def start_fetch(self, cves):
        """
        Performs fetch requests about cves from list
        output: json, csv
        :param cves: list of cves
        :return:
        """
        results = []
        list_length = len(cves)
        for index, cve in enumerate(cves):
            try:
                print(f'[*] [cve_fetch] [{index + 1}/{list_length}] Trying to fetch info about {cve}')

                response = self.api_request(cve.strip())

                try:
                    result = self.parse_cve(cve, response)
                    results.append(result)
                    row = [result['cve'], result['description'], result['cvss']]

                    # backup .json
                    with open(f'{FILE_OUT_JSON}', 'w+', encoding='utf-8', newline='') as file:
                        json.dump(results, file, ensure_ascii=False)

                    # save .csv
                    with open(f'{FILE_OUT_CSV}', 'a+', encoding='utf-8', newline='') as file_out:
                        # create the csv writer
                        writer = csv.writer(file_out)
                        # write a row to the csv file
                        writer.writerow(row)
                except Exception as e:
                    print(f'{RED}[!] [cve_fetch] Response error: {str(e)}{RESET}')
                time.sleep(6)
            except Exception as e:
                print(f'{RED}[!] [cve_fetch] Error in "cve_fetch" module: {str(e)}{RESET}')


def main(args):
    try:
        # region input args parsing
        # Debug mode forces to use hardcoded values, off by default
        if args['debug']:
            global DEBUG_MODE
            DEBUG_MODE = True
            print("[*] [main] Debug mode ON")
            print(args)
        # file descr or domain string (depends on mode)
        search_arg = args['data']
        # 'console' or 'file' mode ('console' by default)
        mode = 'console'
        # trying to get 'file' attribute and open this file
        filename = args['file']
        if filename is not None:
            search_arg = open(f'{filename}', 'r', encoding='utf-8')
            mode = 'file'

        # if something went wrong (no file / no data)
        if search_arg is None:
            raise Exception("No data provided")

        # start
        if mode == 'file':
            file_in_cve = search_arg
            cve_list = file_in_cve.readlines()
            cve_list = [line.rstrip('\n') for line in cve_list]
        else:
            cve_list = [f'{search_arg}']
            # domains_list = ['CVE-2020-0001']
        # endregion
        region_status = check_region()
        if region_status is False:
            if yes_or_no(f'Do you want to continue?') is False:
                return

        cve_parser = CVEparser()
        cve_parser.start_fetch(cve_list)

        if args['stats']:
            file_statistics()
    except Exception as e:
        print(f'{RED}[!] [main] Error: {str(e)}{RESET}')


if __name__ == '__main__':
    args = get_arg()
    main(args)
